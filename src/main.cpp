#include <iostream>
#include <string>

std::string strip(std::string str);
std::string lstrip(std::string str);
int handle_native_commands(std::string command);
int handle_commands(std::string command);

int main() {
  std::cout << std::unitbuf;
  std::cerr << std::unitbuf;

  int status = 1;
  while (true) {
    
    std::cout << "$ ";

    std::string command;
    std::getline(std::cin, command);

    status = handle_native_commands(command);
    if (status==0) {break;} else if (status==1) {continue;} // check status
    status = handle_commands(command);
  }
}

int handle_native_commands(std::string command) {
  if ( strip(command)=="exit" ) {
    return 0; // Exit the shell
  } 
  else if ( lstrip(command).substr(0, 4)=="echo") {
    std::string to_echo = lstrip(command).substr(4); // Get the rest of the command after "echo"
    std::cout << to_echo << std::endl; // Print the echoed string
    return 1;
  } 
  else if (lstrip(command).empty()) {
    return 1;
  } 
  return 2; //continue running
}

int handle_commands(std::string command) {
    if (true) {
      std::cout << command << ": command not found" << std::endl;
      return 2;
    }
}

// AS A RULE FOR USING THE VSCODE AUTOCOMPLETE, I will Always note it, and
// I will research the actual content of the function generated.

/*
 * This function was generated by the VSCode Autocomplete. It should act
 * like Python's str.strip() method, removing leading and trailing whitespace.
 */
std::string strip(std::string str) { 
  // str is a copy of the passed string.
  // str::string& would be a reference to the original string and allow direct edits. 
  const char* whitespace = " \t\n\r\f\v";
  str.erase(0, str.find_first_not_of(whitespace));
  str.erase(str.find_last_not_of(whitespace) + 1);
  return str;
}


/*
 * Like strip, but only removes leading whitespace.
 */
std::string lstrip(std::string str) { 
  const char* whitespace = " \t\n\r\f\v";
  str.erase(0, str.find_first_not_of(whitespace));
  return str;
}